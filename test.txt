闭包（Closure）确实类似于 C++ 中的 lambda 函数，但在 Rust 中有一些独特的特性和语法。让我详细解释：

## 闭包的基本概念

闭包是一种可以捕获其环境的匿名函数。它们可以"记住"创建时的上下文中的变量。

## Rust 闭包语法

```rust
// 基本语法
|参数| { 函数体 }

// 例子
let add = |x, y| x + y;
let result = add(3, 4); // 7
```

## 与 C++ Lambda 对比

| 特性 | C++ Lambda | Rust 闭包 |
|------|------------|-----------|
| 语法 | `[](){}` | `||{}` |
| 捕获列表 | 显式 `[=]`, `[&]`, `[var]` | 自动推断 |
| 返回值 | 可指定 `-> type` | 自动推断或指定 `-> type` |

## Rust 闭包的捕获方式

Rust 闭包自动推断如何捕获变量：

```rust
let x = 10;
let y = 20;

// 1. 不可变借用
let print_sum = || println!("{}", x + y);
print_sum(); // 可以多次调用

// 2. 可变借用
let mut z = 5;
let add_to_z = |n| { z += n; z };
add_to_z(3); // z 现在是 8

// 3. 移动所有权（使用 move 关键字）
let s = String::from("hello");
let take_ownership = move || println!("{}", s);
take_ownership();
// println!("{}", s); // 错误！s 的所有权已移动
```

## 闭包 trait

Rust 闭包实现了以下 trait 之一：
- `Fn` - 不可变借用捕获
- `FnMut` - 可变借用捕获  
- `FnOnce` - 获取所有权，只能调用一次

```rust
fn call_with_one<F>(func: F) -> i32 
where 
    F: Fn(i32) -> i32,
{
    func(1)
}

let double = |x| x * 2;
let result = call_with_one(double); // 2
```

## 实际例子

```rust
// 你之前看到的例子
let v: Vec<i32> = (1..).filter(|x| x % 2 == 0).take(5).collect();

// 分解理解：
// |x| x % 2 == 0 是一个闭包，它：
// - 接受一个参数 x
// - 返回 x % 2 == 0 的结果
// - 自动推断类型为 Fn(i32) -> bool
```

## 与普通函数的区别

```rust
// 普通函数
fn is_even(x: i32) -> bool { x % 2 == 0 }

// 闭包（等效）
let is_even_closure = |x: i32| -> bool { x % 2 == 0 };

// 闭包（类型推断，更简洁）
let is_even_closure = |x| x % 2 == 0;
```

Rust 的闭包设计更加简洁和安全，不需要像 C++ 那样显式指定捕获方式，编译器会自动选择最合适的捕获方式。